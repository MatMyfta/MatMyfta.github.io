<html>
<head>
	<title>Application</title>
	<link rel="stylesheet" href="../style.css">
</head>

<body>

	<table class="header">
		<tr>
			<td colspan="2" class="title">Application</td>
		</tr>

		<tr>
			<td class="left">
				<a href="02architectures.html">prev page</a>
			</td>
			<td class="right">
				<a href="04transport.html">next page</a>
			</td>
		</tr>
	</table>

	<a name="index"></a>
	<ul type=I>
		<li><a href="#princ">Principles of Network Applications</a></li>
		<li><a href="#webhttp">Web and HTTP</a></li>
		<li><a href="#ftp">File Transfer: FTP</a></li>
		<li><a href="#email">Electronic Mail</a></li>
		<li><a href="#dns">DNS</a></li>
		<li><a href="#p2p">Peer-to-Peer Applications</a>
	</ul>

	<hr>
	<p><a name="princ" href="#index">Principles of Network Applications</a></p>

	<p>At the core of network application development is writing programs that run on different end systems and communicate with each other over the network. For example, in the Web application there are two distinct programs that communicate with each other: the browser program running in the user's host; and the Web server program running in the Web server host.<br>
	When developing a new application, you need to write software that will run on multiple end systems. This software could be written in C, Java, Python or other.</p>

	<p>The application architecture is designet by the application developer and dictates how the application is structured over the various end systems. An application developer will likely draw on one of the two predominant architectural paradigms used in modern network applications: the client-server architecture or the peer-to-peer (P2P) architecture.</p>

	<p>In a client-server architecture tere is an always-on host, called server, which services requests from many other hosts called clients. Note that with the client-server architecture multiple clients don't communicate directly with each other. Another characteristic of this architecture is that the server has a fixed, well-known address. Example of client-server applications: FTP, Telnet and e-mail.</p>

	<p>In a P2P architecture, there is minimal reliance on dedicated servers in data centers. Instead the application exploits direct communication between pairs of intermittently connected hosts, called <i>peers</i>. Many of today's most popular applications are based on P2P architectures. These applications include file sharing (BitTorrent), peer-assisted download acceleration (Xunlei), Internet Telephony (Skype), and IPTV.</p>

	<img src="https://blog.resilio.com/wp-content/uploads/2018/06/p2p-vs-client-server-architecture-1170x550.jpg">

	<p>In operating systems, it is not actually programs but processes that communicate. A process can be thought of as a program that is running within an end system. Processes on two different end systems communicate with each other by exchanging messages across the computer network.</p>

	<p>A network application consists of pairs of processes that send messages to each other over a network. For each pair of communicating processes, we typically label one of the two processes as the client and the other process as the server.</p>

	<div class="def">In the context of a communication session between a pair of processes the process that initiates the comminications is labeled as the client. The process that waits to be contacted to begin the session is the server.</div>

	<p>In the Web, a browser process initializes contact with a Web server process; hence the browser process is the client and the Web server process is the server.</p>

	<p>A process sends messages into, and receives messages from, the network through a software interface callde <b>socket</b>. A socket is the interface between the application layer and the transport layer within a host. The only control that the application developer has on the transport-layer side is (1) the choice of transport protocol and (2) perhaps the ability to fix a few transport-layer parameters such as maximum buffer and maximum segment sizes.</p>

	<img src="https://i.stack.imgur.com/4APkp.png">

	<p>In the Internet, the host is identified by its IP address. In addition to knowing the address of the host to which a message is destined, the sending process must also identify the receiving process running in the host. This information is needed because a host could be running many network applications. A destination port number serves this purpose.</p>

	<p>The application at the sending side pushes messages through the socket. Ate the other side of the socket, the transport-layer protocol has the responsibility of getting the messages to the socket of the receiving process. Many networks provide more than one transport-layer protocol.</p>

	<p>For many applications data loss can have devastating consequences. If a protocol provides such a guaranteed data delivery service, it is said to provide reliable data transfer. When a transport protocol provides this service, the sending process can just pass its data into the socket and know with complete confidence that the data will arrive without errors at the receiving process.</p>

	<p>Because other sessions will be sharing the bandwidth along the network path, and because these other sessions will be coming and going, the available throughput can fluctuate with time. These observations lead to another natural service that a transport-layer protocol could provide, namely, guaranteed available throughput at some specified rate.<br>
	Applications that have throughput requirements are said to be bandwidth-sensitive applications. Many current multimedia applications are badnwidth sensitive. Of course, the more throughput, the better.</p>

	<p>A transport-layer protocol can also provide timing guarantees. Timing guarantees can come in many shapes and form.</p>

	<p>A transport protocol can provida an application with one or more security services. It can encrypt all data transmitted by the sending process, and in the receiving host, the transport-layer protocol can decrypt the data before delivering the data to the receiving process.</p>

	<p>The TCP service model includes a connection-oriented service and a reliable data transfer service.</p>

	<p>TCP has the client and server exchange transport layer control information with each other before the application-level messages begin to flow. This so-called handshaking procedure alerts the client and server, allowing them to prepare for an onslaught of packets. After the handshaking phase, a TCP connection is said to exist between the sockets of the two processes. The connection is a full-duplex connection in that the two processes can send messages to each other over the connection at the same time. When the application finishes sending messages, it must tear down the connection.</p>

	<p>The communicating processes can rely on TCP to delive all data sent without error and in the proper order.</p>

	<div class="focus"><p class="focus-title">Securing TCP</p>
	Because privacy and security issues have become critical for many applications, the Internet community has developed an enhancement for TCP, called <b>Secure Sockets Layer (SSL)</b>. It not only does everything that traditional TCP does but also provides critical process-to-process security services, including encryption, data integrity, and endo-point authentication.<br>
	When an application uses SSL, the sending process passes cleartext data to the SSL socket; SSL in the sending host then encrypts the data and passes the encrypted data to the TCP socket. The encrypted data travels over the Internet to the TCP socket in the receiving process. The receiving socket passes the encrypted data to SSL, wich decrypts the data.</div>

	<p>UDP is a no-frills, lightweight transport protocol, providing minimal services. UDP is connectionless, so there is no hanshaking before the two processes start to communicate. UDP provides an unrealiable data transfer service, and provides no guarantee that the message will ever reach the receiving process.</p>

	<p>An application-layer protocol defines how an application√¨s processes, running on different end systems, pass messages to each other. In particular, an application-layer protocol defines:</p>

	<ul>
		<li>The types of messages exchanges, for example request messages and response messages.</li>
		<li>The syntax of the various message types, such as the fields in the message and how the fields are delineated.</li>
		<li>The semantics of the fields.</li>
		<li>Rules for determining when and how a process send messages and responds to messages.</li>
	</ul>	

	<hr>
	<p><a href="#index" name="webhttp">Web and HTTP</a></p>
	<p>The HyperText Transfer Protocol is at the heart of the Web. It is defined in [<a href="https://www.rfc-editor.org/rfc/rfc1945.html">RFC 1945</a>] and [<a href="https://www.rfc-editor.org/rfc/rfc2616.html">RFC 2616</a>]. It is implemented in two programs: a client program and a server program, executing on different end systems, and talk to each other by exchanging HTTP messages.</p>

	<p>HTTP defines how Web clients request Web pages from Web servers and how server transfer Web pages to clients. When a user requests a Web page, the browser send HTTP request messages for the objects in the page to the server. The server receives the requests and responds with HTTP response messages that contain the objects.</p>

	<p>HTTP uses TCP as its underlying transport protocol. The HTTP client first initiates a TCP connection with the server. Once the connection is established, the browser and the server processes access TCP through thir socket interfaces.</p>

	<img src="https://res.cloudinary.com/di2vaxvhl/image/upload/v1545849277/HTTP_txch7g.png">

	<p>In many Internet applications, the client and server communicate for an extended period of time, with the client making a series of request and the server responding to each of the request. An example of a non-persistent connection:</p>

	<ul type=1>
		<li>The HTTP client process initiates a TCP connetcion to the server. Associated with the TCP connection, there will be a socket at the client and a socket at the server.</li>
		<li>The HTTP client sends an HTTP request message to the server via its socket.</li>
		<li>The HTTP server process receives the request message via its socket, retrieves the object from its storage, encapsulates the object in an HTTP response message, and sends the response message to the client via its sockets.</li>
		<li>The HTTP server process tells TCP to close the TCP connection.</li>
		<li>The HTTP client receives the response message. The TCP connection terminates. The message indicates that the encapsulated object is an HTML file. The client extracts the file from the response message, examines the HTML file, and finds references to the JPEG objects.</li>
		<li>The first four steps are then repeated for each of the referenced JPEG objects.</li>
	</ul>

	<img src="https://upload.wikimedia.org/wikipedia/commons/4/46/Prj4.jpeg">

	<p>The round-trip time (RTT) is the time it takes for a small packet to traverl from client to server and then back to client. RTT include packet-propagation delays, packet-queuing delays in intermediate routers and switches, and packet-processing delays.<br>
	When a user clicks to a link he involves a "three-way handshake" - the client sends a small TCP segment to the server, the server acknowledges and responds with a small TCP segment, and, finally, the client acknowledges back to the server. </p>

	<p>With persistent connections, the server leaves the TCP connection open after sending a response. Subsequent request and responses between the same client and server can be sent over the same connection. These requests for objects can be made back-to-back, without waiting for replies to pending requests (pipelining). Typically a HTTP server closes a connection when it isn't used for a certain time (configurable).</p> 

	<p>The HTTP specifications include the definitions of the HTTP message formats. Below we provide a typical HTTP request message:</p>

	<p class="terminal">GET /somedir/page.html HTTP/1.1<br>
	Host: www.someschool.edu<br>
	Connection: close<br>
	User-agent: Mozilla/5.0<br>
	Accept-language: it<br></p>

	<p>The first line of an HTTP request message is called the <b>request line</b>; the subsequent lines are called the <b>header line</b>. The request line has three fields: the method field, the URL field, and the HTTP version field.<br>
	The method field can take on several different values, including GET, POST, HEAD, PUT, and DELETE.</p>

	<img src="http://namho102.github.io/http-presentation/imgs/request_format.png">

	<p>A typical HTTP response message:</p>

	<p class="terminal">HTTP/1.1 200 OK<br>
	Connection: close<br>
	Date: Tue, 09 Aug 2011 15:44:04 GMT<br>
	Server: Apache/2.2.3 (centOS)<br>
	Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br>
	Content-Lenght: 6821<br>
	Content-Type: text/html<br>
	<br>
	(data data data ... )</p>

	<img src="https://slideplayer.com/slide/6960192/24/images/8/HTTP+response+-+general+format.jpg">

	<p>To request see a real HTTP response:</p>

	<p class="terminal">telnet cis.poly.edu 80<br>
		<br>
	GET /~ross/ HTTP/1.1<br>
	Host: cis.poly.edu<br></p>

	<p>HTTP server is stateless, this simplifies server design and has permitted engineers to develop high-performance Web server that can handle thousands of simultaneous TCP connections.<br>
	However it is often desirable for a Web site to identify users, either because the server wishes to restrict user access or because it wants to serve content as a function of the user identity. For these purposes HTTP uses <b>Cookies</b>, defined in [<a href="https://www.rfc-editor.org/rfc/rfc6265.html">RFC 6265</a>], allow sistes to keep track of users.</p>

	<p>It has 4 components</p>
	<ul type=1>
		<li>a cookie header line in the HTTP response message,</li>
		<li>a cookie header line in the HTTP request message,</li>
		<li>a cookie file kept on the user's end system and managed by the user's browser,</li>
		<li>a back-end database at the Web site.</li>
	</ul>

	<img src="https://braindump.jethro.dev/ox-hugo/screenshot_2019-01-25_11-29-28.png">

	<p>The first time a user visits a site, the user can provide a user identification. During the subsequent sessions, the browser passes a cookie header to the server, thereby identifiying the user to the server. Cookies can thus be used to create a user session layer on top of stateless HTTP.</p>

	<p>A Web cache (also called proxy server) is a network entity that satisfies HTTP requests on the behalf of an origin Web server. The Web cache ha its own disk storage and keeps copies of recently requested objects in this storage. Once a browser is configured, each browser request for an object is first directed to the Web cache.</p>

	<ul type=1>
		<li>The browser establishes a TCP connection to the Web cache and sends an HTTP request for the object to the web cache</li>
		<li>The Web cache checks to see if it has a copy of the object stored locally. If it does, it returns the object within an HTTP response message.</li>
		<li>If it doesn't, it opens a TCP connection to the origin server. The Web cace sends an HTTP request for the object into the cache-to-server TCP connection. After receiving the request, the origin server sends the object within an HTTP response.</li>
		<li>When the Web cache receives the object, it stores a copy in its local storage and sends a copy to the client browser.</li>
	</ul>

	<p>Note that a cache is both a server and a client at the same time. When it receives the requests from and sends responses to a browser, it is a server. When it sends requests to and receives responses from an origin server, it is a client.</p>

	<p>Typically a Web cache is purchased and installed by an ISP. Web cache can substantially reduce traffic on an institution's access link to the Internet.</p>

	<p>HTTP has a mechanism that allows a cache to verify that its objects are up to date. This mechanism is called the <b>conditional GET</b>. An HTTP request message is a conditional GET message if</p>
	<ul type=1>
		<li>the request message uses the GET method and</li>
		<li>the request message includes an If-Modified-Since header line.</li>
	</ul>
	<p>Note that the value of the If-modified-since header line is exactly equal to the value fo the Last-Modified header line that was sent by the server on the previous GET request.</p>

	<hr>
	<p><a href="#index" name="ftp">File Transfer: FTP</a></p>
	<p>In a typical FTP [<a href="https://www.rfc-editor.org/rfc/rfc959.html">RFC 959</a>] session, the user is sitting in front of one host and wants to transfer files to or from a remote host. In order for the user to access the remote account, the user must provide a user identification and a password. Once the server has authorized the user, the user copies one or more files stored in the local file system into the remote file system.</p>

	<p>HTTP and FTP are both file transfer protocols and have many common characteristics. However, the most striking difference is that FTP uses two parallel TCP connections to transfer a file, a <b>control connection</b> and a <b>data connection</b>.</p>

	<p>Control connection is used for sending control information between the two hosts. The data connection is used to actually send a file.</p>

	<p>When a user starts an FTP session with a remote host, the client side of FTP first initiates a control TCP connection with the server side on server port number 21. The client side of FTP also sends, over the control connection, commands to change the remote directory. When the server side receives a command for a file transfer over the control connection the server side initiates a TCP data connection to the client side. FTP sends exactly one file over the data connection and then closes it. If, during the same session, the user wants to transfer another file, FTP opens another data connection.</p>

	<p>Throughout a session, the FTP server must maintain state about the user. In particular, the server must associate the control connection with a specific user account, and the server must keep track of the user's current direcory as the user wanders about the remote directory tree.</p>

	<p>FTP commands:</p>

	<ul type=1>
		<li>USER username: send user identification to the server.</li>
		<li>PASS password: send the user password to the server.</li>
		<li>LIST: ask the server to send back a list of all the files in the current remote directory.</li>
		<li>RETR filename: retrieve (get) a file from the current directory of the remote host.</li>
		<li>STOR filename: store (put) a file into the current directory of the remote host.</li>
	</ul>

	<p>FTP typical replies: </p>

	<ul type=1>
		<li>331 Username OK, password required.</li>
		<li>124 Data connection already open; transfer starting.</li>
		<li>425 Can't open data connection.</li>
		<li>452 Error writing file.</li>
	</ul>

	<hr>
	<p><a href="#index" name="email">Electronic Mail</a></p>
	<p>E-mail is an asynchronous communication medium made up of 3 major components: user agents, mail servers, and the Simple Mail Transfer Protocol (SMTP).</p>

	<p>User agents allow user to read, reply to, forward, save, and compose messages. (Es: Outlook).</p>

	<p>Mail servers form the core of the e-mail infrastructure. Each recipient, has a mailbox located in one of the mail servers. When Bob wants to access the messages in his mailbox, the mail server containing his mailbox autheniticates Bob. If Alice's server cannot deliver mail to Bob's server, Alice's server holds the message in a message queue and attempts to transfer the message later.</p>

	<p>SMTP is the principal application-layer protocol for Internet electronic mail. It uses the realiable data transfer service of TCP to transfer mail from the sender's mail server to the recipient's mail server. Both the client side (executed on the client's mail server) and the server side (executed on the recipient's mail server) run on every mail server.</p>

	<p>SMTP [<a href="https://www.rfc-editor.org/rfc/rfc5321.html">RFC 5321</a>] is a legacy technology that possesses certain archaic characteristics. Suppose Alice wants to send Bob a simple ASCII message.</p>

	<ul type=1>
		<li>Alice invokes her user agent for e-mailer, provides Bob's e-mail address, composes a message, and instructs the user agent to send the message.</li>
		<li>Alice's user agent sends the message to her mail server, where it is placed in a message queue.</li>
		<li>The client side of SMTP sees the message in the message queue. It opens a TCP connection to an SMTP server, running on Bob's mail server.</li>
		<li>After some initial SMTP handshaking, the SMTP client sends Alice's message into the TCP connection.</li>
		<li>At Bob's mail server, the server side of SMTP receives the message. Bob's mail server then places the message in Bob's mailbox.</li>
		<li>Bob invokes his user agent to read the message.</li>
	</ul>

	<p>Example of messages exchanged between an SMTP client and an SMTP server:</p>

	<p class="terminal">S: 220 hamburger.edu<br>
	C: HELO crepes.fr<br>
	S: 250 Hello crepes.fr, pleased to meet you<br>
	C: MAIL FROM: <"alice@crepes.fr><br>
	S: 250 alice@crepes.fr ... Sender ok<br>
	C: RCPT TO: <"bob@hamburger.edu><br>
	S: 250 bob@hamburger.edu ... Recipient ok<br>
	C: DATA<br>
	S: 354 Enter mail, end with ‚Äú.‚Äù on a line by itself<br>
	C: Do you like ketchup?<br>
	C: How about pickles?<br>
	C: .<br>
	S: 250 Message accepted for delivery<br>
	C: QUIT<br>
	S: 221 hamburger.edu closing connection<br>
	</p>

	<p>A typical message header looks like:</p>

	<p class="terminal">From: alice@crepes.fr<br>
	To: bob@hamburger.edu<br>
	Subject: Searching for the meaning of life<br></p>

	<p>After the message header, a blank line follows; then the message body (in ASCII) follows.</p>

	<p>There are currently a number of popular mail access protocols, including Post Office Protocol - Version 3 (POP3), Internet Mail Access Protocol (IMAP), and HTTP.</p>

	<p>POP3 [<a href="https://www.rfc-editor.org/rfc/rfc1939.html">RFC 1939</a>] is extremely simple. Begins when the user agent opens a TCP connection to the mail server on port 110. With the TCP connection espablisched, POP3 progresses through three phases: authorization, transaction and update. During the authorization, the user agent sends a username and a password to authenticate the user. During the transaction, the user agent retrieves messages; also during this phase, the user agent can mark messages for deletion, remove deletion marks, and obtain mail statistics. The update, occur after the client has issued the quit command, ending the POP3 session; at this time the mail server deletes the messages that were marked for deletion.<br>
	Problem: Bob may want to access his mail messages from multiple machines. The download-and-delete mode partitions Bob√¨s mail messages over these three machines, in particular if Bob first reads a message on his office PC, he will not be able to reread the message from his portable t home later.<br>
	In the download-and-keep mode he can access a message from work and access it again later from home.<br>
	During the POP3 session server maintains some state information, in particular keeps track of which user messages have been marked deleted.</p>

	<p>The IMAP protocol [<a href="https://www.rfc-editor.org/rfc/rfc3501.html">RFC 3501</a>] has many more features than POP3. AN IMAP server will associate each message with a folder; when a message first arrives at the server, it is associated with the recipient's INBOX folder. The recipient can then move the message into a new user-created folder, read the message, delete the message, and so on.<br>
	The IMAP also provides commands that allow users to search remote folders for messages matching specific criteria, and maintains user state information across IMAP session.<br>
	Another feature is that it has commands that permit a user agent to obtain components of messages.</p>

	<hr>
	<p><a href="#index" name="dns">DNS</a></p>
	<p>DNS is commonly emplyed by other application-layer protocols to translate user-supplied hostnames to IP address. Consider what happens when a browser running on some user's host, request the URL www.someschool.edu/index.html:</p>

	<ul type=1>
		<li>The same user machine runs the client side of the DNS application.</li>
		<li>The browser extracts the hostname from the URL and passes the hostname to the client side of the DNS application.</li>
		<li>The DNS client sends a query containing the hostname to a DNS server.</li>
		<li>The DNS client eventually receives a reply, which includes the IP address for the hostname.</li>
		<li>Onche the browser receives the IP address from DNS, it can initiate a TCP connection to the HTTP server process located at port 80 at that IP address.</li>
	</ul>

	<p>In order to deal with the issue of scale, the DNS uses a large number of servers, organized in a hierarchical fashion and distributed around the world. There are three classes of DNS servers: root DNS servers, top-level domain (TLD) DNS servers, and authoritative DNS servers.</p>

	<img src="http://www.itgeared.com/images/content/1354-2.jpg">

	<p>Although we have referred to each of the 13 root DNS servers as if it were a single server, each "server" is actually a network of replicated servers, for both security and reliability purposes. All together, there was 997 root server in july 2019.</p>

	<p>Top-level domain (TLD) servers are responsible for top-level domains such as com, org, net, edu, gov, and all of the country top-level domains.</p>

	<p>Every organization with publicly accessible hosts on the Internet must provide publicly accessible DNS records that map the names of those hosts to IP addresses.</p>

	<table width=100%><tr>
		<td><center><img src="https://electronicspost.com/wp-content/uploads/2016/05/2.22.png" width=250px></center></td>
		<td><center><img src="https://userpages.umbc.edu/~dgorin1/451/OSI7/dcomm/dns2.JPG" width=250px></center></td>
	</tr></table>

	<p>A critically important feature of the DNS system is DNS caching. DNS extensively exploits DNS caching in order to improve the delay performance and to reduce the number of DNS messages ricocheting around the internet.<br>
	In a query chain, when a DNS server receives a DNS reply, it can cache the mapping in its local memory.</p>

	<p>The DNS servers sotre resource records (RRs). Each DNS reply message carries one or more RRs. A resource record is a four-tuple that contains the following fields:</p>

	<p class="terminal">(Name, Value, Type, TTL)</p>

	<ul>
		<li>If Type=A, then Name is a hostname and value is the IP for the hostname.</li>
		<li>If type=NS then Name is a domain and value is the hostname of an authoritative DNS server that knows how to obtain the IP adresses for hosts in the domain.</li>
		<li>If type=CNAME then value is a canonical hostname for the alias hostname Name.</li>
		<li>If type=MX then value is the canonical name of a mail server that has an alias hostname name.</li>
	</ul>

	<p>DNS message format:</p>

	<img src="https://electronicspost.com/wp-content/uploads/2016/05/2.23.png">

	<ul>
		<li>The first 12 bytes is the header section. The first field is a 16-bit number that identifies the query. This identifier copied into the reply message to a query, allowing the clinet to match received replies with sent queries. There are a number of flags in the flag field.<br>
		A 1-bit query/reply flag indicates whether the message is a query (0) or a reply (1).<br>
		A 1-bit authoritative flag is set in a reply message when a DNS server is an authoritative server for a queried name.<br>
		A 1-bit recursion-desired flag is set when a client desires that the DNS server perform recursion when it doesn't have the record.<br>
		A 1-bit recursion-available field is set in a reply if the DNS server supports recursion.</li>
		<li>The question section contains information about the query that is being made. This includes a name field that contains the name that is being queried, and a type field that indicates the type of question being asket about the name.</li>
		<li>In a reply from a DNS server, the answer section contains the resource records for the name that was originally queried.</li>
		<li>The authority section contains records of other authoritative servers.</li>
		<li>The additional section contains other helpful records.</li>
	</ul>

	<p>A registrar is a commercial entity that verifies the uniqueness of a domain name, enters the domain name into the DNS database, and collects a small fee from you for its services.</p>

	<p>When you register the domain name with some registrar, you also need to provide the registrar with the names and IP address of your primary and secondary authoritative DNS servers. For each of these two authoritative DNS servers, the registrar would then make sure that a Type NS and a Type A record are entered into the TLD com servers.</p>

	<hr>
	<p><a href="#index" name="p2p">Peer-to-Peer Applications</a></p>
	<p>In P2P file distribution, each peer can redistribute any portion of the file it has received to any other peers, thereby assisting the server in the distribution process. The most populare P2P file distribution protocol is BitTorrent.</p>

	<img src="https://hangzhiguo.top/NW-chapter-2/1554012200613.png">

	<p>BitTorrent is a popular P2P protocol for file distribution. The collection of all peers participating in the distribution of a particular file is called a torrent.</p>

	<p>Peers in a torrent download equal-size chunks of the file from one another. When a peer first joins a torrent, it has no chunks. Over time it accumulates more and more chunks. While it download chunks it also uploads chunks to other peers.</p>

	<table class="footer">
		<tr>
			<td class="left"><a href="../index.html">~Index</a></td>
			<td class="right"><a href="index.html">Index reti</a></td>
		</tr>
	</table>


</body>

</html>